# -*- coding: utf-8 -*-

import os
import re

from google.cloud import storage
from google.cloud import speech_v1p1beta1 as speech
from google.oauth2 import service_account

import openai
# import cv2

from typing import List
from pytube import YouTube
from dataclasses import dataclass



#
# Utils
#

def sanitize_filename(filename: str) -> str:
    filename = re.sub(r'[\/:*?"<>|]', '', filename)
    return filename

def split_text_into_sections(text: str, max_tokens: int = 7500) -> List[str]:
    """
    Split text into sections of max_tokens length

    Args:
        text (str): text to split
        max_tokens (int, optional): max length of each section. Defaults to 7500.

    Returns:
        List[str]: list of sections
    """
    paragraphs = text.split("\n\n")
    sections = []
    current_section = ""

    for paragraph in paragraphs:
        if len(current_section) + len(paragraph) <= max_tokens:
            current_section += "\n\n" + paragraph
        else:
            sections.append(current_section)
            current_section = paragraph

    sections.append(current_section)

    return sections


@dataclass
class PipelineParams:
    INTERSECTION_THRESHOLD: float = 0.0
    SECTION_SIZE: int = 7500


class Video2ArticlePipeline:

    def __init__(
            self,
            youtube_link: str,
            json_key_path: str,
            openai_api_key: str,
            params: PipelineParams = PipelineParams()
        ):
        """
        Video to article pipeline

        Args:
            youtube_link (str): = youtube link
            json_key_path (str): path to json key file for google cloud
            openai_api_key (str): openai api key
        """

        self.link = youtube_link
        self.params = params

        credentials = service_account.Credentials.from_service_account_file(json_key_path)
        self.speech2text_storage = storage.Client(credentials=credentials)

        openai.api_key = openai_api_key
    
    def download_audio(self) -> str:
        """
        Download audio from youtube video

        Returns:
            str: path to downloaded audio file (generated by name of video)
        """
        youtube = YouTube(self.link)
        video = youtube.streams.filter(only_audio=True).first()
        audio_stream = video.download()
        audio_file = sanitize_filename(video.title) + ".mp3"
        os.rename(audio_stream, audio_file)
        return audio_file

    def transcribe_audio(self, audio_file: str) -> str:
        """
        Transcribe audio file to text using Google Cloud Speech-to-Text

        Args:
            audio_file (str): path to audio file
        
        Returns:
            str: text from audio file
        """

        # Connect to Google Cloud Storage
        storage_client = self.speech2text_storage 

        # Upload audio file to Google Cloud Storage
        bucket_name = "speech-to-text-qwerty"  
        bucket = storage_client.bucket(bucket_name)
        blob = bucket.blob("audio.mp3")  
        blob.upload_from_filename(audio_file)

        # Create a new Speech Client
        audio_uri = f"gs://{bucket_name}/{blob.name}"
        client = speech.SpeechClient()

        # Create a long running operation
        audio = speech.RecognitionAudio(uri=audio_uri)

        config = speech.RecognitionConfig(
            encoding=speech.RecognitionConfig.AudioEncoding.MP3,
            sample_rate_hertz=16000,
            language_code='ru-RU',
            enable_word_time_offsets=True,
        )

        # Speech to text
        operation = client.long_running_recognize(config=config, audio=audio)
        response = operation.result()

        transcript = ""
        for result in response.results:
            for word_info in result.alternatives[0].words:
                word = word_info.word
                start_time = word_info.start_time.total_seconds()
                transcript += f'{word} ({int(start_time//60)}:{int(start_time%60)}) '

        return transcript

    def gpt_prompt(self, text: str) -> str:
        """
        GPT-3 text update

        Args:
            text (str): raw text

        Returns:
            str: updated text
        """
        start_prompt = """
        Нужно разделить по смысловым частям текст из видео, который я вставлю ниже, и разделить на абзацы - миниумум 1 минута на каждый абзац, но можно и больше. В каждой из них должны быть:
        1. Заголовок, отображающий суть абзаца
        2. Пересказ этого абзаца с сохранением лица в тексте
        3. В начале каждой части поставь тайм код начала этого абзаца на основе меток времени слов в круглых скобках ().
        Каждый абзац должен быть в формате:
        {'title': 'Заголовок', 'text': 'краткое сокращение этой части', 'timecode': '1:10'}

        Кроме абзацев в формате выше ничего присылать не нужно
        """

        sections = split_text_into_sections(text=text, max_tokens=self.params.SECTION_SIZE)

        results = []
        prev_section = None
        for section in sections:
            # take 10% of the previous section and full of the current section
            if prev_section is not None:
                content = start_prompt + '\n' +\
                            prev_section[-int(len(prev_section) * self.params.INTERSECTION_THRESHOLD):] + '\n' + section
            else:
                content = start_prompt + section
                prev_section = section

            response = openai.ChatCompletion.create(
                model="gpt-3.5-turbo-16k",
                messages=[
                    {"role": "system", "content": "You are a helpful assistant."},
                    {"role": "user", "content": content}
                ],
                max_tokens=6000,
                temperature=0.5,
                top_p=0.2,
                stop=None,
            )
            results.append(response.choices[0].message.content.strip())
        return '\n'.join(results)

    def run(self):
        """
        Run pipeline
        """
        audio = self.download_audio()
        text = self.transcribe_audio(audio)
        data = self.gpt_prompt(text)
        return data
